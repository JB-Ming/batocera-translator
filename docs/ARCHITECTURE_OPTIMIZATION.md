# 架構優化建議

## 🎯 當前架構分析

### 現有實現
1. ✅ 多執行緒翻譯（ThreadPoolExecutor）
2. ✅ 維基百科記憶體快取
3. ✅ HTTP Session 重用（Wikipedia only）
4. ✅ 批次處理

### 主要瓶頸

#### 1. **快取不完整** 🔴
- ✅ Wikipedia: 有快取
- ❌ Search: **無快取**
- ❌ Gemini: **無快取**
- ❌ Translate API: 有快取但未持久化

**影響**：重複查詢相同遊戲浪費時間

#### 2. **HTTP 連接未完全重用** 🔴
- ✅ Wikipedia: requests.Session
- ❌ Search: **每次都建立新 Session**
- ❌ Gemini: **無 Session**
- ❌ Translate: **無 Session**

**影響**：TCP 握手開銷，每次請求多花 50-100ms

#### 3. **序列化服務查詢** 🔴
```python
# 當前流程（序列化）
維基 → 等結果 → Gemini → 等結果 → 搜尋 → 等結果
```

**影響**：即使後面的服務可能更快，也要等前面失敗

#### 4. **沒有持久化快取** 🔴
- 程式重啟後快取消失
- 相同遊戲重複翻譯浪費資源

#### 5. **批次 API 未利用** 🟡
- Wikipedia API 支援批次查詢（一次查多個）
- 目前逐個查詢，浪費網路往返時間

---

## 🚀 優化方案

### 方案 1：增加全局快取（最重要）⭐⭐⭐⭐⭐

**實作**：
1. 為所有服務添加記憶體快取
2. 使用 SQLite 持久化快取
3. 快取鍵：`(service, query, language) -> result`

**預期提升**：
- 重複查詢：**0ms**（原 200-2000ms）
- 程式重啟後仍可利用快取
- **速度提升：30-50%**（取決於重複率）

```python
# 快取結構
cache_db = {
    'wikipedia|Super Mario Bros|zh-TW': '超級瑪利歐兄弟',
    'gemini|Zelda|zh-TW': '薩爾達傳說',
    # ...
}
```

---

### 方案 2：HTTP 連接池優化 ⭐⭐⭐⭐

**實作**：
為所有服務添加 Session 重用

```python
# 優化前（每次建立）
response = requests.get(url)  # 每次 TCP 握手 ~50ms

# 優化後（重用連接）
session = requests.Session()
response = session.get(url)   # 重用連接 ~10ms
```

**預期提升**：
- 每次請求節省 40-80ms
- 1000 個遊戲節省 40-80 秒
- **速度提升：5-10%**

---

### 方案 3：並行服務查詢 ⭐⭐⭐⭐⭐

**實作**：
同時查詢多個服務，誰先返回用誰

```python
# 優化前（序列化）
result = wiki() or gemini() or search()  # 最多 3x 時間

# 優化後（並行）
futures = [
    executor.submit(wiki),
    executor.submit(gemini),
    executor.submit(search)
]
result = first_completed(futures)  # 最快的時間
```

**預期提升**：
- 最壞情況從 3s → 1s
- **速度提升：30-50%**（針對需要搜尋的遊戲）

**注意**：會浪費一些 API 請求

---

### 方案 4：批次 API 查詢 ⭐⭐⭐

**實作**：
利用 Wikipedia API 的批次查詢功能

```python
# 優化前
for game in games:
    wiki.search(game)  # N 次網路請求

# 優化後
wiki.batch_search([game1, game2, ...])  # 1 次網路請求
```

**預期提升**：
- 網路往返從 N 次 → N/10 次
- **速度提升：20-30%**（針對維基查詢）

---

### 方案 5：預取語系包 ⭐⭐

**實作**：
程式啟動時預先載入常用遊戲翻譯

```python
# 啟動時載入 Top 1000 熱門遊戲翻譯
preload_cache = load_popular_games()
```

**預期提升**：
- 熱門遊戲命中率 80%+
- 大幅減少 API 查詢

---

### 方案 6：智能重試與降級 ⭐⭐

**實作**：
- API 失敗時自動重試（exponential backoff）
- 檢測到限流時自動降速

---

## 📊 優化優先級與投資回報

| 方案 | 難度 | 效益 | 優先級 | 預期提升 |
|------|------|------|--------|----------|
| 1. 全局快取 | 中 | 極高 | ⭐⭐⭐⭐⭐ | **30-50%** |
| 2. HTTP 連接池 | 低 | 中 | ⭐⭐⭐⭐ | 5-10% |
| 3. 並行查詢 | 中 | 高 | ⭐⭐⭐⭐⭐ | **30-50%** |
| 4. 批次 API | 高 | 中高 | ⭐⭐⭐ | 20-30% |
| 5. 預取語系包 | 低 | 中 | ⭐⭐ | 視情況 |
| 6. 智能重試 | 中 | 中 | ⭐⭐ | 提升穩定性 |

---

## 🎁 建議實作順序

### 第一階段（快速見效）
1. ✅ HTTP 連接池（30 分鐘）
2. ✅ 全局記憶體快取（1 小時）

**預期提升：20-30%**

### 第二階段（重大優化）
3. ✅ SQLite 持久化快取（2 小時）
4. ✅ 並行服務查詢（3 小時）

**累計提升：50-80%**

### 第三階段（精益求精）
5. ✅ 批次 API 查詢（4 小時）
6. ✅ 預取語系包（1 小時）

**累計提升：70-100%（2倍速）**

---

## 💡 其他優化點

### 資料庫優化
- 字典檔使用 SQLite 而非 JSON
- 減少 I/O 開銷

### 記憶體優化
- 使用 LRU 快取限制大小
- 避免記憶體溢出

### UI 優化
- 虛擬列表（大量遊戲時）
- 降低更新頻率

---

## 🤔 要實作哪個？

我建議先做 **方案 1（全局快取）+ 方案 2（HTTP 連接池）**，這兩個：
- ✅ 實作簡單
- ✅ 效果顯著
- ✅ 風險低
- ✅ **合計提升 25-35%**

要我開始實作嗎？
